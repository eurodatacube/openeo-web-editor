{"version":3,"sources":["webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js"],"names":["SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","resolution","pixelRatio","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","LOADED","ERROR","unlistenImageChange","IDLE","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","replay","drawCustom","getHitDetectionRenderer","geometries","getGeometries","i","ii","length","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","declutterImageWithText","imageBuilderGroup","declutterMode","getDeclutterMode","imageReplay_1","setImageStyle","drawPoint","imageReplay","textBuilderGroup","imageReplay_2","drawMultiPoint","drawPolygon","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WebGLWorkerMessageType","GENERATE_BUFFERS","_super","WebGLLayerRenderer","layer","opt_options","_this","options","inversePixelTransform_","pixelContext_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","bind","dispatchPreComposeEvent","dispatchPostComposeEvent","context","frameState","getLayer","hasListener","PRECOMPOSE","event_1","undefined","dispatchEvent","POSTCOMPOSE","event_2","reset","setUniforms","dispose","prepareFrame","getRenderSource","incrementGroup","groupNumber","className","layerStatesArray","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","disposeInternal","dispatchRenderEvent_","type","size","event_3","preRender","PRERENDER","postRender","POSTRENDER","getDataAtPixel","pixel","hitTolerance","renderPixel","slice","gl","getGL","layerExtent","getExtent","renderCoordinate","pixelToCoordinateTransform","attributes","getContextAttributes","preserveDrawingBuffer","Uint8Array","data","x","Math","round","y","pixelContext","pixelCanvas","document","createElement","width","height","getContext","clearRect","drawImage","canvas","getImageData","err","Layer","colorEncodeId","id","opt_array","array","radix","divide","floor","colorDecodeId","color","mult","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","ready","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","map","attribute","name","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","addEventListener","event","received","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","generateBuffersRun","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","getProgram","renderFrame","projection","viewState","vectorSource","multiWorld","getWrapX","canWrapX","projectionExtent","extent","worldWidth","endWorld","ceil","startWorld","world","renderCount","getSize","makeProjectionTransform","applyUniforms","drawElements","finalizeDraw","renderHitDetection","clearCachedData","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","sourceChanged","getRevision","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","getFlatCoordinates","Number","value","j","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","matches","coordinateToPixelTransform","readPixel","index","opacity","uid","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate","layer_","forEach","key"],"mappings":"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","file":"js/chunk-b63012a2.6944f836.js","sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == 'GeometryCollection') {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageBuilderGroup = builderGroup;\n        if (opt_declutterBuilderGroup) {\n            var declutterMode = imageStyle.getDeclutterMode();\n            if (declutterMode !== 'none') {\n                imageBuilderGroup = opt_declutterBuilderGroup;\n                if (declutterMode === 'obstacle') {\n                    // draw in non-declutter group:\n                    var imageReplay_1 = builderGroup.getBuilder(style.getZIndex(), 'Image');\n                    imageReplay_1.setImageStyle(imageStyle, declutterImageWithText);\n                    imageReplay_1.drawPoint(geometry, feature);\n                }\n                else if (textStyle && textStyle.getText()) {\n                    declutterImageWithText = {};\n                }\n            }\n        }\n        var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textBuilderGroup = builderGroup;\n        if (opt_declutterBuilderGroup) {\n            textBuilderGroup = opt_declutterBuilderGroup;\n        }\n        var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageBuilderGroup = builderGroup;\n        if (opt_declutterBuilderGroup) {\n            var declutterMode = imageStyle.getDeclutterMode();\n            if (declutterMode !== 'none') {\n                imageBuilderGroup = opt_declutterBuilderGroup;\n                if (declutterMode === 'obstacle') {\n                    // draw in non-declutter group:\n                    var imageReplay_2 = builderGroup.getBuilder(style.getZIndex(), 'Image');\n                    imageReplay_2.setImageStyle(imageStyle, declutterImageWithText);\n                    imageReplay_2.drawMultiPoint(geometry, feature);\n                }\n                else if (textStyle && textStyle.getText()) {\n                    declutterImageWithText = {};\n                }\n            }\n        }\n        var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textBuilderGroup = builderGroup;\n        if (opt_declutterBuilderGroup) {\n            textBuilderGroup = opt_declutterBuilderGroup;\n        }\n        var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate } from '../../extent.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        _this.pixelContext_ = null;\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getRenderSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                this.removeHelper();\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        var renderPixel = applyTransform([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            var renderCoordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n            /** get only data inside of the layer extent */\n            if (!containsCoordinate(layerExtent, renderCoordinate)) {\n                return null;\n            }\n        }\n        var attributes = gl.getContextAttributes();\n        if (!attributes || !attributes.preserveDrawingBuffer) {\n            // we assume there is data at the given pixel (although there might not be)\n            return new Uint8Array();\n        }\n        var x = Math.round(renderPixel[0]);\n        var y = Math.round(renderPixel[1]);\n        var pixelContext = this.pixelContext_;\n        if (!pixelContext) {\n            var pixelCanvas = document.createElement('canvas');\n            pixelCanvas.width = 1;\n            pixelCanvas.height = 1;\n            pixelContext = pixelCanvas.getContext('2d');\n            this.pixelContext_ = pixelContext;\n        }\n        pixelContext.clearRect(0, 0, 1, 1);\n        var data;\n        try {\n            pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);\n            data = pixelContext.getImageData(0, 0, 1, 1).data;\n        }\n        catch (err) {\n            return data;\n        }\n        if (data[3] === 0) {\n            return null;\n        }\n        return data;\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, translate as translateTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals, getWidth } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.ready = false;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        /**\n         * Keep track of latest message sent to worker\n         * @type {number}\n         * @private\n         */\n        _this.generateBuffersRun_ = 0;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                    if (received.generateBuffersRun === this.generateBuffersRun_) {\n                        this.ready = true;\n                    }\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var projection = frameState.viewState.projection;\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        // FIXME fix hit detection isn't reliable when rendering multiple worlds\n        var multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n        var projectionExtent = projection.getExtent();\n        var extent = frameState.extent;\n        var worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n        var endWorld = multiWorld\n            ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n            : 1;\n        var startWorld = multiWorld\n            ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n            : 0;\n        var world = startWorld;\n        var renderCount = this.indicesBuffer_.getSize();\n        do {\n            // apply the current projection transform with the invert of the one used to fill buffers\n            this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n            translateTransform(this.currentTransform_, world * worldWidth, 0);\n            multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n            this.helper.applyUniforms(frameState);\n            this.helper.drawElements(0, renderCount);\n        } while (++world < endWorld);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== 'Point') {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        message['generateBuffersRun'] = ++this.generateBuffersRun_;\n        this.ready = false;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {number} startWorld the world to render in the first iteration\n     * @param {number} endWorld the last world to render\n     * @param {number} worldWidth the width of the worlds being rendered\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState, startWorld, endWorld, worldWidth) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        var world = startWorld;\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        do {\n            this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n            translateTransform(this.currentTransform_, world * worldWidth, 0);\n            multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n            this.helper.applyUniforms(frameState);\n            var renderCount = this.indicesBuffer_.getSize();\n            this.helper.drawElements(0, renderCount);\n        } while (++world < endWorld);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map"],"sourceRoot":""}